---
title: "PICA"
pubDate: 2025-09-17T00:00+09:00
startDate: 2025-08-11
endDate: 2025-09-17
description: "결제 시 최대 혜택을 받을 수 있는 카드를 자동으로 선택해 주는 서비스"
thumbnail: '../../assets/projects/PICA/PICA_Icon.webp'
heroImage: '../../assets/projects/PICA/PICA_Hero.webp'
gitLab: "https://lab.ssafy.com/s13-fintech-finance-sub1/S13P21A109"
gitLabPrivate: true
link: "https://pica.r-e.kr/"
linkClosed: true
teamSize: "6명"
tags: ["Spring Boot", "PostgreSQL", "JPA", "AWS", "Redis", "Prometheus", "Grafana", "k6"]
---

import { Image } from 'astro:assets';
import screen1 from '../../assets/projects/pica/PICA_Screen1.gif';
import screen2 from '../../assets/projects/pica/PICA_Screen2.gif';
import architecture from '../../assets/projects/pica/PICA_Architecture.webp';

## [개요]

- 가맹점에서 제공하는 QR을 스캔하면, 사용자가 보유한 카드 중 최대 혜택을 제공하는 카드로 자동 결제되는 오프라인 결제서비스
- 담당
    - 결제 시스템 아키텍처 설계 및 핵심 로직 구현
    - 결제 REST API 및 ERD 설계 (요청·승인·취소·내역)
    - 멱등성 기반 중복 결제 방지, 결제 상태 머신 도입
    - 결제 복구/취소 및 대사(정합성 검증) 프로세스 설계
    - Prometheus·Grafana·k6 기반 부하 테스트 및 성능 개선

## [사용 기술 스택 및 선정 이유]

### Backend

- Java 17 / Spring Boot
    - 트랜잭션 경계가 중요한 로직을 안정적으로 관리하기 위해 사용
    - 결제 상태 전이와 예외 처리를 명확한 서비스 계층으로 분리하기 용이
- Spring Data JPA
    - 도메인 간 관계를 엔티티 중심으로 표현하기 위해 사용
    - 멱등성 보장을 위해 DB 제약 조건과 함께 활용
    - 대량 조회 및 성능 이슈 발생 구간에서는 fetch join, EntityGraph, 쿼리 재작성으로 대응
- Spring Scheduler
    - 결제 재시도, 취소 처리, 대사 처리를 비동기적으로 처리하기 위해 사용

---

### DB / Cache

- PostgreSQL
    - 데이터를 관계형 모델로 관리하기 위해 사용
    - 트랜잭션 안정성과 정합성이 중요한 결제 도메인에 적합하다고 판단
    - 인덱스 및 제약 조건을 활용해 대량 데이터 환경에서도 무결성 유지
    - MVCC 기반 동시성 제어 방식으로, 읽기 작업이 쓰기 작업에 의해 블로킹되지 않도록 동작
        - 결제 승인/조회가 동시에 발생하는 상황에서도 조회 지연 최소화
    - MySQL 잠금 기반 동시성 제어와 비교했을 때
        - 읽기 시점의 스냅샷을 유지하여 트랜잭션 간 간섭 감소
    - 격리 수준 : READ COMMITTED
        - 결제 도메인의 주요 트랜잭션은 대부분 단건 결제, 취소와 같은 행 단위 처리
        - 동일 트랜잭션 내에서 동일 데이터를 반복 조회해야 하는 시나리오가 적어 REPEATABLE READ가 불필요하다고 판단
        - 결제 승인, 취소와 같이 정합성이 중요한 구간은 SELECT FOR UPDATE를 통해 충돌 방지
            - 중복 결제 방지는 멱등성 키 및 DB 제약 조건으로 보완
        - 불필요한 락 경합과 트랜잭션 대기를 줄여 속도에서 유리한 READ COMMITTED 선택
- Redis
    - JWT 인증에서 로그아웃 및 토큰 강제 만료 처리를 위해 블랙리스트 관리
    - 결제 요청 시 멱등 처리 과정에서 보조 캐시로 활용해 중복 요청에 대한 DB 접근을 최소화
    - 카드 상품 조회 등 반복 조회로 인한 DB 접근 최소화

---

### Infra / DevOps

- Docker Compose
    - 개발, 테스트, 운영 환경 간 차이를 최소화하기 위해 컨테이너 기반 환경 구성
    - Spring Boot, PostgreSQL, Redis를 하나의 Compose 스택으로 관리
    - 서비스 간 네트워크를 Compose 서비스명 기반으로 통일하여 설정 단순화
- GitLab CI/CD
    - 빌드 및 배포 과정을 자동화하여 수동 배포로 인한 오류를 줄이기 위해 사용
    - Docker Executor 기반 Runner를 사용해 실행 환경을 컨테이너로 통일
    - .env 파일은 GitLab Variables(File 타입)로 관리하여 보안과 편의성 확보
- AWS EC2
    - 서비스 배포 및 운영 환경으로 사용
    - Docker 기반 배포로 서버 환경 의존성을 최소화

---

### Monitoring / Testing

- Prometheus
    - API 응답 시간, 처리량 등 서버 지표 수집을 위해 사용
    - 성능 병목 구간을 수치 기반으로 파악
- Grafana
    - Prometheus에서 수집한 메트릭을 시각화
    - 부하 테스트 전후 성능 변화를 비교 분석
- k6
    - 조회 API에 대한 부하 테스트
    - 대량 사용자(VU) 환경에서의 응답 시간, 실패율, 처리량을 측정하여 성능 개선 근거 확보

---

### External API

- SSAFY 금융망 API
    - 카드 인증, 승인, 취소 등 결제 플로우를 실제 금융 시스템과 유사하게 구현하기 위해 사용
    - 멱등성 보장, 에러 코드 기반 처리 등 결제 시스템 설계 관점의 경험을 쌓는 데 목적

## **[주요 담당 기능]**

### 1. 결제 시스템 아키텍처 설계 및 핵심 도메인 구현

- QR 기반 결제를 중심으로 결제 요청 → 승인 → 취소 → 청구까지 이어지는 엔드투엔드 결제 흐름을 설계 및 구현
- 결제 도메인 기준으로 Payment / Transaction / CancelEvent / Ledger 등 핵심 엔티티 및 관계를 정의하고 ERD 설계
- 결제 처리 로직을 단순 API 호출이 아닌 상태 기반 흐름으로 모델링하여 예외 상황 대응 가능하도록 구성

---

### 2. 결제 REST API 및 트랜잭션 처리

- 결제 요청, 승인, 취소, 결제 내역 조회를 위한 결제 REST API 설계 및 구현
- 승인·취소·청구 단계에서 트랜잭션 경계를 명확히 분리하여 외부 금융망 API 장애 시에도 내부 상태가 일관되게 유지되도록 처리
- 외부 API 호출은 트랜잭션 외부에서 수행하고, 상태 변경은 REQUIRES_NEW 트랜잭션으로 커밋 보장    
    → 예외 발생 시에도 중복 처리 및 상태 유실 방지
---

### 3. 결제 상태 머신(State Machine) 도입

- 결제 처리의 불확실성을 관리하기 위해 결제 상태 머신을 직접 설계 및 적용
    - NOT_STARTED → EXECUTING → DONE / FAILED / UNKNOWN
- 승인 요청 중 시스템 중단, 네트워크 지연 등으로 결과를 확정할 수 없는 경우 UNKNOWN 상태로 관리
- 일정 시간 이상 EXECUTING 상태가 지속되면 UNKNOWN으로 전환하여 재시도·대사 대상에 포함

---

### 4. 멱등성 기반 중복 결제 방지

- 금융망 API의 transactionId를 멱등성 키로 활용하여 동일 결제 요청이 여러 번 들어와도 항상 하나의 결과만 처리되도록 설계
- JPA 엔티티에 Unique Constraint를 적용하여 DB 레벨에서도 중복 결제 방지
- 사용자 중복 클릭, 새로고침, 네트워크 재요청 상황에서도 결제 데이터 무결성 보장

---

### 5. 금융망 API 연동 안정성 및 재시도 전략

- 금융망 API 장애 및 네트워크 지연으로 인한 결제 결과 불일치 가능성을 고려한 에러 처리 전략 수립
- 금융망이 멱등성을 보장한다는 전제하에,
    - 재시도 가능한 에러 코드([확인 필요: 실제 사용한 에러 코드 목록])에 대해 지수 백오프 기반 재시도 로직(최대 3회) 구현
    - 재시도 불가 에러는 즉시 실패 처리하여 사용자 응답 지연 방지
- 일정 횟수 이상 실패 시 결제 상태를 UNKNOWN으로 기록 후 스케줄러 기반 후처리로 이관

---

### 6. 결제 취소 및 복구 프로세스 설계

- 승인 결과를 받기 전에 취소 요청이 들어오는 상황을 대비해 CANCEL_REQUESTED 상태 도입
- 취소 요청 시 즉시 금융망 호출을 수행하지 않고 DB에 취소 요청만 기록
- 비동기 스케줄러가 주기적으로 취소 이벤트를 조회하여 다음 기준으로 처리
    - 원거래 SUCCESS → 금융망 취소 요청
    - 원거래 FAIL → 취소 불필요 처리
    - 원거래 UNKNOWN → 다음 주기로 이월
- 거래 번호 미수신 상황에서는 가맹점·카드·금액 기준으로 거래 내역 조회 후 취소 재시도
- 취소 성공/실패 결과를 명확한 상태(CANCEL_SUCCESS / CANCEL_FAIL)로 관리

---

### 7. 대사(Reconciliation) 및 정합성 검증 로직 구현

- 금융망 정산 데이터와 내부 결제 데이터를 비교하는 대사 프로세스 설계
- 대사 결과를 다음 3가지 상태로 분류
    - 대사일치
    - 대사불일치
    - 대사불능
- 대사불일치 발생 시 관리자 검증 경로 및 자동 재처리 플로우 제공
- 주기적 대사를 통해 UNKNOWN 상태 결제를 재확인하여 결제 유실 가능성 최소화

---

### 8. 장부(Ledger) 기반 결제 이력 관리

- 승인, 취소, 혜택 적용 등 모든 결제 이벤트를 장부에 기록
- Wallet / Transaction / Benefit 테이블 설계 및 연관 관계 정의
- 결제 DB와 장부 DB를 분리하여 이중 기록 구조로 데이터 무결성 강화
- 추후 대사·정산을 고려한 집계 쿼리 및 인덱스 구조 설계

---

### 9. 부하 테스트 및 성능 개선

- Prometheus와 Grafana를 활용해 결제 및 조회 API 모니터링 환경 구축
- k6를 사용한 부하 테스트 시나리오 설계 및 실행
- 1000 VU 환경에서 10만 건 전수 조회 성능 측정
- 쿼리 최적화 및 캐싱 적용으로 응답 시간 44초 → 13초로 개선

---

### 10. GitLab CI/CD 파이프라인 구축 및 운영 이슈 해결

- GitLab Runner 기반 CI/CD 파이프라인을 구축하여 빌드, 배포 자동화 환경 구성
- Shell Executor 사용 시 권한 문제 및 환경 차이로 job 실행 실패가 반복적으로 발생
    - 로컬 경로 접근 권한 문제 및 쉘 초기화 파일 충돌 이슈 확인
- Shell Executor 대신 Docker Executor로 전환하여 실행 환경을 컨테이너 기반으로 통일
- Docker Executor 전환 후 다음 문제를 해결
    - 기본 job 컨테이너에 docker CLI가 없는 문제
    - privileged 모드 미설정으로 host Docker 접근 불가 문제
- docker:20.10 이미지 사용 및 GitLab Runner 설정에 privileged 옵션 추가로 docker-in-docker 환경 구성
- CI/CD 환경과 서버 실행 환경 간 차이를 줄여 배포 안정성 확보

---

### 11. 배포 환경 Git 충돌 및 파일 관리 정책 정립

- EC2 서버에 수동으로 생성한 docker-compose.yaml, Dockerfile과 GitLab 원격 저장소 간 충돌 발생
- 서버에 직접 생성된 파일을 제거하고, 모든 설정 파일을 Git 저장소에서 관리하도록 구조 정리
- 배포는 GitLab CI/CD 파이프라인을 통해서만 수행하도록 정책 정립
- 서버 수동 작업으로 인한 설정 불일치 및 배포 실패 가능성 제거

---

### 12. 환경 변수(.env) 관리 및 보안 이슈 해결

- .env 파일을 Git에 포함하지 않아 배포 시 파일 누락 및 파싱 오류 발생
- GitLab CI Variables의 File 타입을 활용해 .env 파일 내용을 안전하게 저장
- CI 단계에서 scp를 통해 서버로 .env 파일을 주입하도록 구성
- docker compose에서 인식 가능한 형식만 허용되도록 .env 포맷 정리
    - KEY=VALUE 형식만 사용
    - 주석은 #으로 통일
- 보안과 배포 안정성을 동시에 만족하는 환경 변수 관리 방식 확립

---

### 13. Docker Compose 기반 배포 안정성 확보

- 재배포 시 기존 컨테이너가 남아 있어 동일 이름으로 컨테이너 생성 실패 문제 발생
- 배포 파이프라인에 docker compose down 단계를 추가한 뒤 build 및 up -d 수행
- 배포 과정에서 컨테이너 충돌로 인한 장애 방지
- 컨테이너 로그는 docker logs -f 명령어로 실시간 확인하도록 운영 가이드 정리

---

### 14. 빌드 환경과 실행 환경의 Java 버전 불일치 해결

- 애플리케이션이 JDK 21로 빌드되었으나 Docker 실행 환경은 JDK 17을 사용하여 런타임 오류 발생
- Dockerfile의 base image를 eclipse-temurin:21-jdk로 변경
- CI 빌드 환경과 Docker 실행 환경의 Java 버전을 통일
- 빌드 환경과 실행 환경 간 버전 불일치로 발생할 수 있는 오류 사전 차단

---

### 15. Docker Compose 네트워크 기반 DB 및 Redis 연결 구성

- Spring Boot .env의 DB_HOST, REDIS_HOST 값과 Docker Compose 서비스 이름 불일치로 연결 실패 발생
- Compose 서비스 이름을 기준으로 DB 및 Redis에 접근하도록 환경 변수 수정
- 컨테이너 간 통신에서는 포트 포워딩 없이 서비스명 기반 접근이 가능함을 확인
- 컨테이너 네트워크 구조에 대한 이해를 바탕으로 설정 단순화

---

### 16. 대규모 데이터 조회 성능 최적화 및 부하 테스트

- Prometheus와 Grafana를 활용해 API 성능 지표 모니터링 환경 구축
- k6를 활용해 카드 상품 조회 API에 대한 부하 테스트 시나리오 설계
    - 30초 ramp-up, 최대 1000 VU, 대량 조회 트래픽 시뮬레이션
- 카드 상품 전수 조회(/cards/all)에서 다음 문제를 확인
    - 대량 연관 엔티티 로딩으로 인한 응답 지연 및 높은 실패율
- JPA fetch join 기반 쿼리 최적화 적용
    - CardProduct, Issuer, Benefit 연관 관계를 한 번에 조회
- 쿼리 최적화 후 평균 응답 시간 44초 → 28초로 개선
- Caffeine 캐시 적용 후 평균 응답 시간 13초 수준으로 추가 개선
- 요청 실패율을 80%대에서 3% 수준으로 감소
- tail latency(p90, max)가 여전히 높은 이슈는 추가 분석 대상으로 분류
    - [확인 필요: CPU, GC, 네트워크 병목 여부]

---

### 17. 검색 API 성능 개선 및 쿼리 구조 개선

- 카드 상품 검색(/cards/search) API에서 N+1 문제 발생
    - CardProduct, CardProductBenefit, Category 간 연관 관계로 다수 쿼리 발생
- EntityGraph를 활용해 필요한 연관 엔티티를 즉시 로딩하도록 개선
- 대량 데이터 환경에서 GROUP BY 기반 집계 쿼리 대신 NOT EXISTS 기반 쿼리로 재작성
- 복합 인덱스 및 Unique 제약조건을 활용해 검색 성능 개선
    - [수정 가능: 실제 인덱스 명 및 컬럼 구성]
- Pagination 적용 및 캐싱을 병행하여 검색 API 응답 안정성 확보

## [트러블 슈팅]

TODO

## **[주요 화면]**

<div style="display: flex; gap: 1.5rem; margin: 2rem 0; flex-wrap: wrap;">
  <div style="flex: 1; min-width: 300px; display: flex; justify-content: center;">
    <Image src={screen1} alt="주요화면1" />
  </div>
  <div style="flex: 1; min-width: 300px; display: flex; justify-content: center;">
    <Image src={screen2} alt="주요화면2" />
  </div>
</div>

## [아키텍처 구조]

<Image src={architecture} alt="아키텍처 구조" />

